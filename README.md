# deep-proxy-monitor
> A simple library to make nested proxies and monitoring the access to every single properties of an object including nested ones from arrays and objects.

<br/>
The library exposes two functions (`deepProxy` and `proxyMonitor`) to make custom nested proxy and monitor objects.  You can monitoring all the properties inside an object by reading the values of the monitor object generated by the library or customize your own handler.

This is useful for detect unused properties of an input object data to improve performance issues on large projects with a bunch of data.

Is recommended use only for development stages until the library could be ready for production scenarios and testing the performance cases.


<br/>

## Installation

```sh
npm install --save-dev deep-proxy-monitor
```

<br/>

## Usage example

### deepProxy

By using the `deepProxy` function you can create a nested proxy to trap the access to any nested element inside the target object:

```
// CommonJS
const { deepProxy } = require('deep-proxy-monitor')

// or ESM
import { deepProxy } from 'deep-proxy-monitor'

const testObj = {
  foo: 'foo',
  bar: [{
    baz: 'baz',
    zoo: {
      cat: 'cat'
    }
  }]
}

const handler = {
  get: function (target, prop) {
    console.log(`Accessing to ${prop}`)
    return target[prop]
  }
}

const proxy = deepProxy(testObj, handler)

console.log(proxy.foo)
console.log(proxy.bar[0].zoo.cat)
```

Output:

```
Accessing to foo
foo
Accessing to bar
Accessing to zoo
Accessing to cat
cat
```

### proxyMonitor

Another important and useful use case is to monitoring the access to all elements of an object by watching the monitor object given by then `proxyMonitor` function:

```
// CommonJS
const { proxyMonitor } = require('deep-proxy-monitor')

// or ESM
import { proxyMonitor } from 'deep-proxy-monitor'

const testObj = {
  foo: 'foo',
  bar: [{
    baz: 'baz',
    zoo: {
      cat: 'cat'
    }
  }]
}

const [proxy, monitor] = proxyMonitor(testObj)

console.log(proxy.foo)
console.log(proxy.bar[0].zoo.cat)
console.log(JSON.stringify(monitor))
```

Output:

```
foo
cat
{"foo":true,"bar":[{"baz":false,"zoo":{"cat":true}}]}
```

The default handler for the `proxyMonitor` function is to assign `true` or `false` when an element is accessed or not. You can customize the handler function passing a second argument to the `proxyMonitor` function like:

```
// CommonJSo
const { proxyMonitor } = require('deep-proxy-monitor')

// or ESM
import { proxyMonitor } from 'deep-proxy-monitor'

const testObj = {
  foo: 'foo',
  bar: [{
    baz: 'baz',
    zoo: {
      cat: 'cat'
    }
  }]
}

const monitorStrategy = {
  defaultValue: 0,
  strategy: (objToMonitor, prop) => {
    // count the number of element access
    if (typeof objToMonitor[prop] === 'number') {
      ++objToMonitor[prop]
    }
  }
}

const [proxy, monitor] = proxyMonitor(testObj, monitorStrategy)

console.log(proxy.foo)
console.log(proxy.bar[0].zoo.cat)
console.log(JSON.stringify(monitor))
```

Outputs

```
foo
cat
{"foo":1,"bar":[{"baz":0,"zoo":{"cat":1}}]}
```

For more examples, you can see the tests cases inside the `test` folder.

<br/>

## Author

Stevens Pineda – [@ScolDev](https://youtube.com/ScolDev) – yo@stevenscol.co

Distributed under the MIT license. See ``LICENSE`` for more information.

<br/>

## Contributing

1. Fork it (https://github.com/ScolDev/deep-proxy-monitor/fork)
2. Create your feature branch (`git checkout -b feature/fooBar`)
3. Commit your changes (`git commit -am 'Add some fooBar'`)
4. Push to the branch (`git push origin feature/fooBar`)
5. Create a new Pull Request